# 五、递归运算：遍历

您可能知道，递归编程是一种有争议的技术，因为它通常需要大量内存，但它简化了一些编程任务。基本上，递归编程是这样一种情况:过程调用自身，传入一个或多个参数的修改值，这些参数被传入到过程的当前迭代中。计算阶乘、斐波那契数、字谜和 Sierpinski 地毯等编程任务只是可以通过递归编程技术完成的一些众所周知的任务。下面的代码片段使用这种技术来计算阶乘(n！= 1 * 2 * 3 *……* n)—请注意该过程如何调用自己:

```java
/**
  * Calculate the factorial of n (n! = 1 * 2 * 3 * … * n).
  *
  * @param n the number to calculate the factorial of.
  * @return n! - the factorial of n.
  */
static int fact(int n) {

   // Base Case:
   // If n <= 1 then n! = 1.
   if (n <= 1) {
       return 1;
   }
   // Recursive Case:  
   // If n > 1 then n! = n * (n-1)!
   else {
        return n * fact(n-1);
        }
   }
```

如果您已经熟悉这种编程技术，那么请继续阅读本章，看看 NIO.2 如何利用它。否则，在您继续阅读一些致力于递归编程的教程之前，这是一个好主意，例如 Jonathan Bartlett 的“掌握递归编程”，可在`[www.ibm.com/developerworks/linux/library/l-recurs/index.html](http://www.ibm.com/developerworks/linux/library/l-recurs/index.html)`获得。

许多涉及使用文件的编程任务需要访问文件树中的所有文件，这是使用递归编程机制的好机会，因为每个文件都应该单独“接触”。在执行删除、复制或移动文件树等任务时，这是一种非常常见的方法。基于这种机制，NIO.2 将文件树的遍历过程封装在一个名为`FileVisitor`的接口中，在`java.nio.file`包中。

本章首先介绍`FileVisitor`的范围和方法。一旦您熟悉了`FileVisitor`，本章将帮助您开发一套应用，您可以用它来执行涉及遍历文件树的任务，比如查找、复制、删除和移动文件。

### file visitor 接口

如前所述，`FileVisitor`接口支持递归遍历文件树。该接口的方法表示遍历过程中的关键点，使您能够在访问文件时、访问目录前、访问目录后以及发生故障时进行控制；换句话说，这个接口在访问文件之前、期间和之后都有挂钩，在出现故障时也有挂钩。一旦您拥有了控制权(在这些关键点的任何一点上)，您就可以选择如何处理被访问的文件，并通过`FileVisitResult`枚举指示访问结果来决定接下来应该对它做什么，该枚举包含四个枚举常量:

*   `FileVisitResult.CONTINUE`:这个访问结果表示遍历过程应该继续。根据返回哪个`FileVisitor`方法，它可以被翻译成不同的动作。例如，遍历过程可以通过访问下一个文件、访问目录条目或跳过失败来继续。
*   `FileVisitResult.SKIP_SIBLINGS`:这个访问结果表示遍历过程应该继续，而不访问这个文件或目录的兄弟。
*   `FileVisitResult.SKIP_SUBTREE`:这个访问结果表示遍历过程应该继续，而不访问这个目录中的其余条目。
*   `FileVisitResult.TERMINATE`:该访问结果表示遍历过程应该终止。

此枚举类型的常数可以迭代如下:

```java
for (FileVisitResult constant : FileVisitResult.values())
    System.out.println(constant);
```

以下小节讨论了如何通过实现各种`FileVisitor`方法来控制遍历过程。

#### FileVisitor.visitFile()方法

为目录中的文件调用`visitFile()`方法。通常，这个方法返回一个`CONTINUE`结果或者一个`TERMINATE`结果。例如，当搜索一个文件时，该方法应该返回`CONTINUE`直到找到该文件(或者完全遍历该树)，并在找到该文件后返回`TERMINATE`。

当这个方法被调用时，它接收对文件的引用和文件的基本属性。如果发生 I/O 错误，那么它抛出一个`IOException`异常。以下是此方法的签名:

```java
FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException
```

#### file visitor . previsitdirectory()方法

在访问目录条目之前，为目录调用`preVisitDirectory()`方法。如果方法返回`CONTINUE`将访问条目，如果返回`SKIP_SUBTREE`将不访问条目(后一个访问的结果只有从该方法返回时才有意义)。此外，通过返回`SKIP_SIBLINGS`结果，您可以跳过访问该文件或目录的同级(以及任何后代)。

当这个方法被调用时，它获得对目录和目录的基本属性的引用。如果发生 I/O 错误，那么它抛出一个`IOException`异常。这个方法的特征是

```java
FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException
```

#### file visitor . postvisit directory()方法

在已经访问了目录中的所有条目(以及任何后代)或者访问突然结束(即，发生了 I/O 错误或者访问以编程方式中止)之后，调用`postVisitDirectory()`方法。当这个方法被调用时，它获得一个对目录和`IOException`对象的引用——如果访问期间没有发生错误，它将是`null`,如果发生错误，它将返回相应的错误。如果发生 I/O 错误，那么它抛出一个`IOException`异常。下面是这个方法的签名

```java
FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException
```

#### FileVisitor.visitFileFailed()方法

当文件由于各种不同的原因而无法访问时，例如无法读取文件的属性或无法打开目录，就会调用`visitFileFailed()`方法。当调用此方法时，它会获取对该文件的引用以及在尝试访问该文件时发生的异常。如果发生 I/O 错误，那么它抛出一个`IOException`异常。以下是此方法的签名:

```java
FileVisitResult visitFileFailed(T file, IOException exc) throws IOException
```

### 简单文件访问者类

实现`FileVisitor`接口需要实现它的所有方法，如果您只需要实现其中的一个或几个方法，这可能是不可取的。在这种情况下，扩展实现了`FileVisitor`接口的`SimpleFileVisitor`类就简单多了。这种方法只需要覆盖所需的方法。

例如，您可能想要遍历文件树并列出所有目录的名称。要实现这一点，只使用`postVisitDirectory()`和`visitFileFailed()`方法就足够了，如下面的代码片段所示(起始文件树在下一节中给出):

`class ListTree extends SimpleFileVisitor<Path> {

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) {

        System.out.println("Visited directory: " + dir.toString());

        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) {`  `System.out.println(exc);

        return FileVisitResult.CONTINUE;
    }
}`

如您所见，跳过了`preVisitDirectory()`和`visitFile()`方法。

### 开始递归过程

一旦创建了递归机制(通过实现`FileVisitor`接口或扩展`SimpleFileVisitor`类)，就可以通过调用两个`Files.walkFileTree()`方法之一来启动这个过程。最简单的`walkFileTree()`方法获取起始文件(这通常是文件树根)和每个文件要调用的文件访问者(这是递归机制类的一个实例)。例如，您可以通过如下方式调用`walkFileTree()`方法来启动上一节中的代码示例(传递的文件树是`C:\rafaelnadal`):

```java
Path listDir = Paths.get("C:/rafaelnadal"); //define the starting file tree
ListTree walk = new ListTree();             //instantiate the walk

try{
   Files.walkFileTree(listDir, walk);       //start the walk
   } catch(IOException e){
     System.err.println(e);
   }
```

第二个`walkFileTree()`方法获取开始文件、定制遍历的选项、要访问的最大目录级别数(为了确保遍历所有级别，可以为最大深度参数指定`Integer.MAX_VALUE`)和遍历实例。接受的选项是`FileVisitOption`枚举的常量。实际上，这个枚举包含一个名为`FOLLOW_LINKS`的常量，表示遍历中遵循了符号链接(默认情况下，它们没有被遵循)。

为前面的遍历调用此方法可能如下所示:

```java
Path listDir = Paths.get("C:/rafaelnadal");              //define the starting file
ListTree walk = new ListTree();                          //instantiate the walk
EnumSet opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS); //follow links

try{
   Files.walkFileTree(listDir, opts, Integer.MAX_VALUE, walk); //start the walk
   } catch(IOException e){
     System.err.println(e);
   }
```

![Image](images/square.jpg) **注**呼叫`walkFileTree(start, visitor)`与呼叫`walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)`效果相同。

以下几行是前面示例的输出:

* * *

```java
Visited directory: C:\rafaelnadal\equipment

Visited directory: C:\rafaelnadal\grandslam\AustralianOpen

Visited directory: C:\rafaelnadal\grandslam\RolandGarros

Visited directory: C:\rafaelnadal\grandslam\USOpen

Visited directory: C:\rafaelnadal\grandslam\Wimbledon

Visited directory: C:\rafaelnadal\grandslam

…

Visited directory: C:\rafaelnadal
```

* * *

### 常见的散步

有一组常见的遍历，您可以通过`FileVisitor`接口轻松实现。本节向您展示如何编写和实现应用来执行文件搜索、递归复制、递归移动和递归删除。

#### 编写文件搜索应用

大多数操作系统都提供了搜索文件的专用工具(例如，Linux 有`find`命令，而 Windows 有文件搜索工具)。从简单搜索到高级搜索，所有工具通常都以相同的方式工作:指定搜索条件，然后等待工具找到匹配的文件。但是，如果您需要以编程方式完成搜索，那么`FileVisitor`可以帮助您完成遍历过程。无论您是按名称、扩展名或 glob 模式查找文件，还是在文件内部查找一些文本或代码，方法总是访问文件存储中的每个文件并执行一些检查，以确定文件是否符合您的搜索标准。

当您基于`FileVisitor`编写文件搜索工具时，您需要记住以下几点:

*   `visitFile()`方法是在当前文件和您的搜索标准之间进行比较的最佳位置。此时，您可以提取每个文件名、扩展名或属性，或者打开文件进行阅读。您可以使用文件名、扩展名等来确定所访问的文件是否是所搜索的文件。有时，您会将这些信息混合到复杂的搜索标准中。这种方法找不到目录。
*   如果您想要查找目录，那么比较必须在`preVisitDirectory()`或`postVisitDirectory()`方法中进行，这取决于大小写。
*   如果一个文件不能被访问，`visitFileFailed()`方法应该返回`FileVisitResult.CONTINUE`，因为这个问题不需要停止整个搜索过程。
*   如果您按名称搜索一个文件，并且您知道在文件树中有一个同名的文件，那么一旦`visitFile()`方法找到它，您就可以返回`FileVisitResult.TERMINATE`。否则，`FileVisitResult.CONTINUE`应该被退回。
*   搜索过程可以遵循符号链接，这可能是一个好主意，因为遵循符号链接可以在遍历符号链接的目标子树之前定位所搜索的文件。跟随符号链接并不总是一个好主意；例如，删除文件是不可取的。

##### 按名称搜索文件

可以将前面的列表合并到下面的代码片段中，以生成一个按名称搜索文件的应用。该应用将在整个默认文件系统中搜索文件`rafa_1.jpg`，并在找到时停止搜索。

`import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitOption;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.EnumSet;

class Search implements FileVisitor {

    private final Path searchedFile;
    public boolean found;

    public Search(Path searchedFile) {
        this.searchedFile = searchedFile;
        this.found = false;
    }

void search(Path file) throws IOException {
        Path name = file.getFileName();
        if (name != null && name.equals(searchedFile)) {
            System.out.println("Searched file was found: " + searchedFile +
                                                   " in " + file.toRealPath().toString());
            found = true;
        }
    }

    @Override` `    public FileVisitResult postVisitDirectory(Object dir, IOException exc)
                                              throws IOException {
        System.out.println("Visited: " + (Path) dir);
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult preVisitDirectory(Object dir, BasicFileAttributes attrs)
                                             throws IOException {
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFile(Object file, BasicFileAttributes attrs)
                                     throws IOException {
        search((Path) file);
        if (!found) {
            return FileVisitResult.CONTINUE;
        } else {
            return FileVisitResult.TERMINATE;
        }
    }

    @Override
    public FileVisitResult visitFileFailed(Object file, IOException exc)
                                           throws IOException {
        //report an error if necessary
        return FileVisitResult.CONTINUE;
    }
}

class Main {

    public static void main(String[] args) throws IOException {

        Path searchFile = Paths.get("rafa_1.jpg");
        Search walk = new Search(searchFile);
        EnumSet opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);

        Iterable<Path> dirs = FileSystems.getDefault().getRootDirectories();
        for (Path root : dirs) {
            if (!walk.found) {
                Files.walkFileTree(root, opts, Integer.MAX_VALUE, walk);
            }
        }

        if (!walk.found) {
            System.out.println("The file " + searchFile + " was not found!");
        }
    }
}`

输出的一个片段可能如下所示:

* * *

```java
…

Visited: C:\Python25\Tools\webchecker

Visited: C:\Python25\Tools

Visited: C:\Python25

…

Visited: C:\rafaelnadal\equipment

Visited: C:\rafaelnadal\grandslam\AustralianOpen

Visited: C:\rafaelnadal\grandslam\RolandGarros

Visited: C:\rafaelnadal\grandslam\USOpen

Visited: C:\rafaelnadal\grandslam\Wimbledon

Visited: C:\rafaelnadal\grandslam

-------------------------------------------------------------

Searched file was found: rafa_1.jpg in C:\rafaelnadal\photos\rafa_1.jpg
```

* * *

##### 通过全局模式搜索文件

有时，您可能只有关于您要搜索的文件的部分信息，例如只有它的名称或扩展名，或者甚至可能只有它的名称或扩展名的一部分。基于这一小段信息，您可以编写一个 glob 模式，如在第 4 章“通过应用 Glob 模式列出内容”一节中所描述的搜索将在文件存储中定位所有匹配 glob 模式的文件，从结果中您可能能够找到您需要定位的文件。

下面的代码片段在`C:\rafaelnadal`文件树中搜索所有类型为`*.jpg`的文件。只有遍历完整个树后，该过程才会停止。

`import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitOption;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.Paths;` `import java.nio.file.attribute.BasicFileAttributes;
import java.util.EnumSet;

class Search implements FileVisitor {

    private final PathMatcher matcher;

    public Search(String glob) {
        matcher = FileSystems.getDefault().getPathMatcher("glob:" + glob);        
    }

    void search(Path file) throws IOException {
        Path name = file.getFileName();
        if (name != null && matcher.matches(name)) {
            System.out.println("Searched file was found: " + name +
                                                     " in " + file.toRealPath().toString());
        }
    }

    @Override
    public FileVisitResult postVisitDirectory(Object dir, IOException exc)
                                                                      throws IOException {
        System.out.println("Visited: " + (Path) dir);
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult preVisitDirectory(Object dir, BasicFileAttributes attrs)
                                                                      throws IOException {
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFile(Object file, BasicFileAttributes attrs)
                                                                      throws IOException {
        search((Path) file);
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFileFailed(Object file, IOException exc)
                                                                      throws IOException {
        //report an error if necessary
        return FileVisitResult.CONTINUE;
    }
}

class Main {

    public static void main(String[] args) throws IOException {` `        String glob = "*.jpg";
        Path fileTree = Paths.get("C:/rafaelnadal/");
        Search walk = new Search(glob);
        EnumSet opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);

        Files.walkFileTree(fileTree, opts, Integer.MAX_VALUE, walk);

    }
}`

输出片段显示了找到的文件:

* * *

```java
Searched file was found: rafa_1.jpg in C:\rafaelnadal\photos\rafa_1.jpg

Searched file was found: rafa_winner.jpg in C:\rafaelnadal\photos\rafa_winner.jpg

…
```

* * *

如果您有关于要查找的文件的附加信息，那么您可以创建一个更复杂的搜索。例如，除了关于文件名和类型的小块信息之外，也许您知道文件大小小于某个千字节数，或者也许您知道诸如文件创建时间、文件最后修改时间、文件是隐藏的还是只读的，或者谁拥有它。附加信息可能是文件属性的一部分，如下面的代码片段所示，该代码片段将`*.jpg` glob 模式与小于 100KB 的文件大小相结合(您可能知道，大小是一个基本属性):

`import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitOption;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.EnumSet;

class Search implements FileVisitor {

    private final PathMatcher matcher;
    private final long accepted_size;

    public Search(String glob, long accepted_size) {
        matcher = FileSystems.getDefault().getPathMatcher("glob:" + glob);
        this.accepted_size = accepted_size;        
    }

    void search(Path file) throws IOException {
        Path name = file.getFileName();` `        long size = (Long) Files.getAttribute(file, "basic:size");

        if (name != null && matcher.matches(name) && size <= accepted_size) {
            System.out.println("Searched file was found: " + name + " in " +
                                  file.toRealPath().toString() + " size (bytes):" + size);
        }
    }

    @Override
    public FileVisitResult postVisitDirectory(Object dir, IOException exc)
                                                                      throws IOException {
        System.out.println("Visited: " + (Path) dir);
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult preVisitDirectory(Object dir, BasicFileAttributes attrs)
                                                                      throws IOException {
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFile(Object file, BasicFileAttributes attrs)
                                                                      throws IOException {
        search((Path) file);
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFileFailed(Object file, IOException exc)
                                                                      throws IOException {
        //report an error if necessary
        return FileVisitResult.CONTINUE;
    }
}

class Main {

    public static void main(String[] args) throws IOException {

        String glob = "*.jpg";
        long size = 102400; //100 kilobytes in bytes
        Path fileTree = Paths.get("C:/rafaelnadal/");
        Search walk = new Search(glob, size);
        EnumSet opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);

        Files.walkFileTree(fileTree, opts, Integer.MAX_VALUE, walk);      
    }
}`

以下是找到的文件输出的片段:

* * *

```java
Searched file was found: rafa_winner.jpg in C:\rafaelnadal\photos\rafa_winner.jpg size (bytes):77718

…
```

* * *

##### 按内容搜索文件

其中一种高级文件搜索包括按内容查找文件。您传递一系列单词或句子，搜索只返回包含该文本的文件。这是最耗时的文件搜索任务，因为它需要在每个访问过的文件中搜索文本，这意味着打开文件，阅读文件，最后关闭文件。此外，还有许多支持文本的文件格式，如 PDF、Microsoft Word、Excel 和 PowerPoint、简单文本文件、XML、HTML、XHTML 等等。每种格式都有不同的读取方式，这需要能够从中提取文本文件的专用代码。

在这一节中，我们将开发一个根据内容搜索文件的应用。要搜索的文本作为包含由逗号分隔的单词或句子序列的`String`传递；比如:“拉斐尔·纳达尔，网球，罗兰·加洛斯冠军，巴黎银行锦标赛平局”。使用`StringTokenizer`类，逗号作为分隔符，下面的示例将每个单词和句子提取到一个`ArrayList`中:

```java
…
String words="Rafael Nadal,tennis,winner of Roland Garros,BNP Paribas tournament draws";
ArrayList<String> wordsarray = new ArrayList<>();
…
StringTokenizer st = new StringTokenizer(words, ",");
while (st.hasMoreTokens()) {
       wordsarray.add(st.nextToken());
}
```

下面的代码循环这个`ArrayList`，并将每个单词和句子与从被访问文件中提取的文本进行比较。注意在`searchText()`方法中，提取的文本作为参数传递。

```java
//search text
private boolean searchText(String text) {

   boolean flag = false;
   for (int j = 0; j < wordsarray.size(); j++) {
        if ((text.toLowerCase()).contains(wordsarray.get(j).toLowerCase())) {
            flag = true;
            break;
       }
   }
   return flag;
}
```

下面的小节集中在从一些最常见的文件格式中提取文本并进行比较的一组方法。因为我们不打算在这里重新发明轮子，我们将利用一些专门为理解特定文件格式而编写的第三方库。然后我们将把我们开发的每一种方法组合成一个完整的搜索程序。

###### 在 pdf 中搜索

为了阅读 PDF 文件，我们将使用两个最流行的第三方开源库，iText 和 Apache PDFBox。您可以从`[http://itextpdf.com/](http://itextpdf.com/)`下载 iText 库，从`[http://pdfbox.apache.org/](http://pdfbox.apache.org/)`下载 PDFBox 库。出于本章的目的，我使用了 iText 的 5.1.2 版本和 PDFBox 的 1.6.0 版本。基于 iText 文档，我编写了下面的方法来从 PDF 中提取文本。第一步是在被访问的文件上创建一个`PdfReader`。继续提取 PDF 的页数，从每一页提取文本，并将提取的文本传递给`searchText()`方法。如果在提取的文本中找到其中一个标记，那么在当前文件中的搜索将停止，该文件将被视为有效的搜索结果，其路径和名称将被存储，以便我们可以在整个搜索结束后将其打印出来。

```java
//search in PDF files using iText library
boolean searchInPDF_iText(String file) {

   PdfReader reader = null;
   boolean flag = false;

   try {
       reader = new PdfReader(file);
       int n = reader.getNumberOfPages();

       OUTERMOST:
       for (int i = 1; i <= n; i++) {
         String str = PdfTextExtractor.getTextFromPage(reader, i);

         flag = searchText(str);
         if (flag) {
               break OUTERMOST;
         }
       }

   } catch (Exception e) {
      } finally {
          if (reader != null) {
              reader.close();
            }
            return flag;
      }
}
```

如果你对 PDFBox 比对 iText 更熟悉，那么试试下面的方法。首先在 PDF 文件上创建一个`PDFParser`，然后提取页数，最后提取每页的文本并将其传递给`searchText()`方法。

`boolean searchInPDF_PDFBox(String file) {

   PDFParser parser = null;
   String parsedText = null;` `   PDFTextStripper pdfStripper = null;
   PDDocument pdDoc = null;
   COSDocument cosDoc = null;
   boolean flag = false;
   int page = 0;

   File pdf = new File(file);

   try {
       parser = new PDFParser(new FileInputStream(pdf));
       parser.parse();

       cosDoc = parser.getDocument();
       pdfStripper = new PDFTextStripper();
       pdDoc = new PDDocument(cosDoc);

       OUTERMOST:
       while (page < pdDoc.getNumberOfPages()) {
            page++;
            pdfStripper.setStartPage(page);
            pdfStripper.setEndPage(page + 1);
            parsedText = pdfStripper.getText(pdDoc);

            flag = searchText(parsedText);
            if (flag) {
                 break OUTERMOST;
            }
       }
   } catch (Exception e) {
   } finally {
          try {
             if (cosDoc != null) {
                  cosDoc.close();
             }
             if (pdDoc != null) {
                  pdDoc.close();
             }
          } catch (Exception e) {}
   return flag;
   }
}`

###### 在 Microsoft Word、Excel 和 PowerPoint 文件中搜索

Microsoft Office 套件的文件可以通过 Apache POI 库进行操作，Apache POI 库是 Microsoft 文档最常用的 Java API。你可以从`[http://poi.apache.org/](http://poi.apache.org/)`下载这个库。出于本章的目的，我使用了 3.7 版本。根据开发人员指南，我编写了以下从 Word 文档中提取文本的方法。Apache POI 提取一个包含 Word 文档所有段落的数组`String`。数组可以循环，每一段都可以传递给`searchText()`方法。

```java
boolean searchInWord(String file) {

   POIFSFileSystem fs = null;
   boolean flag = false;

   try {
       fs = new POIFSFileSystem(new FileInputStream(file));

       HWPFDocument doc = new HWPFDocument(fs);
       WordExtractor we = new WordExtractor(doc);
       String[] paragraphs = we.getParagraphText();

       OUTERMOST:
       for (int i = 0; i < paragraphs.length; i++) {

             flag = searchText(paragraphs[i]);
             if (flag) {
                   break OUTERMOST;
             }
       }

     } catch (Exception e) {
     } finally {
            return flag;
     }
}
```

我们可以从 Excel 文件中提取文本，如下例所示。在为 Excel 文档创建了一个`HSSFWorkbook`之后，基本思想是遍历工作表，然后遍历行，最后遍历单元格。单元格应该包含我们要查找的特定文本。

`boolean searchInExcel(String file) {

   Row row;
   Cell cell;
   String text;
   boolean flag = false;
   InputStream xls = null;

   try {
       xls = new FileInputStream(file);
       HSSFWorkbook wb = new HSSFWorkbook(xls);

       int sheets = wb.getNumberOfSheets();

       OUTERMOST:
       for (int i = 0; i < sheets; i++) {
            HSSFSheet sheet = wb.getSheetAt(i);

            Iterator<Row> row_iterator = sheet.rowIterator();
            while (row_iterator.hasNext()) {
                row = (Row) row_iterator.next();` `                Iterator<Cell> cell_iterator = row.cellIterator();
                while (cell_iterator.hasNext()) {
                    cell = cell_iterator.next();
                    int type = cell.getCellType();
                    if (type == HSSFCell.CELL_TYPE_STRING) {
                          text = cell.getStringCellValue();
                          flag = searchText(text);
                          if (flag) {
                                break OUTERMOST;
                          }
                    }
                }
            }
       }

   } catch (IOException e) {
   } finally {
         try {
             if (xls != null) {
                    xls.close();
             }
         } catch (IOException e) {}
   return flag;
   }
}`

最后，我们可以从 PowerPoint 文件中提取文本，如下例所示；每张幻灯片可能包含文本和注释:

`boolean searchInPPT(String file) {

   boolean flag = false;
   InputStream fis = null;
   String text;

   try {
       fis = new FileInputStream(new File(file));
       POIFSFileSystem fs = new POIFSFileSystem(fis);
       HSLFSlideShow show = new HSLFSlideShow(fs);

       SlideShow ss = new SlideShow(show);
       Slide[] slides = ss.getSlides();

       OUTERMOST:
       for (int i = 0; i < slides.length; i++) {

          TextRun[] runs = slides[i].getTextRuns();
          for (int j = 0; j < runs.length; j++) {
             TextRun run = runs[j];
             if (run.getRunType() == TextHeaderAtom.TITLE_TYPE) {
                 text = run.getText();
             } else {` `                 text = run.getRunType() + " " + run.getText();
             }

             flag = searchText(text);
             if (flag) {
                    break OUTERMOST;
             }
          }

       Notes notes = slides[i].getNotesSheet();
       if (notes != null) {
           runs = notes.getTextRuns();
           for (int j = 0; j < runs.length; j++) {
                text = runs[j].getText();
                flag = searchText(text);
                if (flag) {
                      break OUTERMOST;
                }
           }
       }
     }
   } catch (IOException e) {
   } finally {
         try {
           if (fis != null) {
                 fis.close();
             }
          } catch (IOException e) {}
   return flag;
   }
}`

![Image](images/square.jpg) **注意**我任意选择了前面例子中使用的第三方库。还有许多其他的开源和商业库可以用来处理不同种类的文档。请随意使用任何方便您需求的东西。我们的搜索示例并不是最有效的搜索方式。在最坏的情况下，我们必须遍历整个数组(典型情况下是数组的一半)。也许使用 Apache Lucene ( `[http://lucene.apache.org/java/docs/index.html](http://lucene.apache.org/java/docs/index.html)`)提供的索引搜索是更好的方法。这是一个你可以自己尝试的练习。

###### 在文本文件中搜索

文本文件(`.txt`、`.html`、`.xml`等)。)不需要第三方库。可以使用纯 NIO.2 代码读取它们，如下所示:

`boolean searchInText(Path file) {`  `boolean flag = false;
   Charset charset = Charset.forName("UTF-8");
   try (BufferedReader reader = Files.newBufferedReader(file, charset)) {
        String line = null;

        OUTERMOST:
        while ((line = reader.readLine()) != null) {
              flag = searchText(line);
              if (flag) {
                   break OUTERMOST;
              }
        }

    } catch (IOException e) {
    } finally {
          return flag;
    }
}`

##### 编写一个完整的搜索程序

没错。馅饼做好了！把它扔进烤箱！我们有搜索的文本、从一组常见文件格式中提取的文本，以及检查提取的文本是否包含搜索的文本的方法。将所有东西放入遍历过程，应用就准备好了:

`import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.parser.PdfTextExtractor;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitOption;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.StringTokenizer;
import org.apache.pdfbox.cos.COSDocument;
import org.apache.pdfbox.pdfparser.PDFParser;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.util.PDFTextStripper;
import org.apache.poi.hslf.HSLFSlideShow;
import org.apache.poi.hslf.model.Notes;
import org.apache.poi.hslf.model.Slide;` `import org.apache.poi.hslf.model.TextRun;
import org.apache.poi.hslf.record.TextHeaderAtom;
import org.apache.poi.hslf.usermodel.SlideShow;
import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.hwpf.HWPFDocument;
import org.apache.poi.hwpf.extractor.WordExtractor;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;

class Search implements FileVisitor {

    ArrayList<String> wordsarray = new ArrayList<>();
    ArrayList<String> documents = new ArrayList<>();
    boolean found = false;

    public Search(String words) {
        wordsarray.clear();
        documents.clear();

        StringTokenizer st = new StringTokenizer(words, ",");
        while (st.hasMoreTokens()) {
            wordsarray.add(st.nextToken().trim());
        }
    }

    void search(Path file) throws IOException {

        found = false;

        String name = file.getFileName().toString();
        int mid = name.lastIndexOf(".");
        String ext = name.substring(mid + 1, name.length());

        if (ext.equalsIgnoreCase("pdf")) {
            found = searchInPDF_iText(file.toString());
            if (!found) {
                found = searchInPDF_PDFBox(file.toString());
            }
        }

        if (ext.equalsIgnoreCase("doc") || ext.equalsIgnoreCase("docx")) {
            found = searchInWord(file.toString());
        }

        if (ext.equalsIgnoreCase("ppt")) {
            searchInPPT(file.toString());
        }

        if (ext.equalsIgnoreCase("xls")) {` `searchInExcel(file.toString());
        }

        if ((ext.equalsIgnoreCase("txt")) || (ext.equalsIgnoreCase("xml")
                                          || ext.equalsIgnoreCase("html"))
                || ext.equalsIgnoreCase("htm") || ext.equalsIgnoreCase("xhtml")
                                               || ext.equalsIgnoreCase("rtf")) {
            searchInText(file);
        }

        if (found) {
            documents.add(file.toString());
        }
    }

    //search in text files
    boolean searchInText(Path file) {

        boolean flag = false;
        Charset charset = Charset.forName("UTF-8");
        try (BufferedReader reader = Files.newBufferedReader(file, charset)) {
            String line = null;

            OUTERMOST:
            while ((line = reader.readLine()) != null) {
                flag = searchText(line);
                if (flag) {
                    break OUTERMOST;
                }
            }

        } catch (IOException e) {
        } finally {
            return flag;
        }
    }

    //search in Excel files
    boolean searchInExcel(String file) {

        Row row;
        Cell cell;
        String text;
        boolean flag = false;
        InputStream xls = null;

        try {
            xls = new FileInputStream(file);
            HSSFWorkbook wb = new HSSFWorkbook(xls);

            int sheets = wb.getNumberOfSheets();`  `OUTERMOST:
            for (int i = 0; i < sheets; i++) {
                HSSFSheet sheet = wb.getSheetAt(i);

                Iterator<Row> row_iterator = sheet.rowIterator();
                while (row_iterator.hasNext()) {
                    row = (Row) row_iterator.next();
                    Iterator<Cell> cell_iterator = row.cellIterator();
                    while (cell_iterator.hasNext()) {
                        cell = cell_iterator.next();
                        int type = cell.getCellType();
                        if (type == HSSFCell.CELL_TYPE_STRING) {
                            text = cell.getStringCellValue();
                            flag = searchText(text);
                            if (flag) {
                                break OUTERMOST;
                            }
                        }
                    }
                }
            }

        } catch (IOException e) {
        } finally {
            try {
                if (xls != null) {
                    xls.close();
                }
            } catch (IOException e) {
            }
            return flag;
        }
    }

    //search in PowerPoint files
    boolean searchInPPT(String file) {

        boolean flag = false;
        InputStream fis = null;
        String text;

        try {
            fis = new FileInputStream(new File(file));
            POIFSFileSystem fs = new POIFSFileSystem(fis);
            HSLFSlideShow show = new HSLFSlideShow(fs);

            SlideShow ss = new SlideShow(show);
            Slide[] slides = ss.getSlides();

            OUTERMOST:
            for (int i = 0; i < slides.length; i++) {`  `TextRun[] runs = slides[i].getTextRuns();
                for (int j = 0; j < runs.length; j++) {
                    TextRun run = runs[j];
                    if (run.getRunType() == TextHeaderAtom.TITLE_TYPE) {
                        text = run.getText();
                    } else {
                        text = run.getRunType() + " " + run.getText();
                    }

                    flag = searchText(text);
                    if (flag) {
                        break OUTERMOST;
                    }

                }

                Notes notes = slides[i].getNotesSheet();
                if (notes != null) {
                    runs = notes.getTextRuns();
                    for (int j = 0; j < runs.length; j++) {
                        text = runs[j].getText();
                        flag = searchText(text);
                        if (flag) {
                            break OUTERMOST;
                        }
                    }
                }
            }

        } catch (IOException e) {
        } finally {
            try {
                if (fis != null) {
                    fis.close();
                }
            } catch (IOException e) {
            }
            return flag;
        }

    }

    //search in Word files
    boolean searchInWord(String file) {

        POIFSFileSystem fs = null;
        boolean flag = false;

        try {
            fs = new POIFSFileSystem(new FileInputStream(file));

            HWPFDocument doc = new HWPFDocument(fs);` `WordExtractor we = new WordExtractor(doc);
            String[] paragraphs = we.getParagraphText();

            OUTERMOST:
            for (int i = 0; i < paragraphs.length; i++) {

                flag = searchText(paragraphs[i]);
                if (flag) {
                    break OUTERMOST;
                }
            }`  `} catch (Exception e) {
        } finally {
            return flag;
        }
    }

    //search in PDF files using PDFBox library
    boolean searchInPDF_PDFBox(String file) {

        PDFParser parser = null;
        String parsedText = null;
        PDFTextStripper pdfStripper = null;
        PDDocument pdDoc = null;
        COSDocument cosDoc = null;
        boolean flag = false;
        int page = 0;

        File pdf = new File(file);

        try {
            parser = new PDFParser(new FileInputStream(pdf));
            parser.parse();

            cosDoc = parser.getDocument();
            pdfStripper = new PDFTextStripper();
            pdDoc = new PDDocument(cosDoc);

            OUTERMOST:
            while (page < pdDoc.getNumberOfPages()) {
                page++;
                pdfStripper.setStartPage(page);
                pdfStripper.setEndPage(page + 1);
                parsedText = pdfStripper.getText(pdDoc);

                flag = searchText(parsedText);
                if (flag) {
                    break OUTERMOST;
                }
            }

        } catch (Exception e) {
        } finally {
            try {
                if (cosDoc != null) {
                    cosDoc.close();
                }
                if (pdDoc != null) {
                    pdDoc.close();
                }
            } catch (Exception e) {
            }
            return flag;
        }
    }

    //search in PDF files using iText library
    boolean searchInPDF_iText(String file) {

        PdfReader reader = null;
        boolean flag = false;

        try {
            reader = new PdfReader(file);
            int n = reader.getNumberOfPages();

            OUTERMOST:
            for (int i = 1; i <= n; i++) {
                String str = PdfTextExtractor.getTextFromPage(reader, i);

                flag = searchText(str);
                if (flag) {
                    break OUTERMOST;
                }
            }

        } catch (Exception e) {
        } finally {
            if (reader != null) {
                reader.close();
            }
            return flag;
        }

    }

    //search text
    private boolean searchText(String text) {

        boolean flag = false;
        for (int j = 0; j < wordsarray.size(); j++) {
            if ((text.toLowerCase()).contains(wordsarray.get(j).toLowerCase())) {
                flag = true;` `break;
            }
        }

        return flag;
    }

    @Override
    public FileVisitResult postVisitDirectory(Object dir, IOException exc)
                                                                      throws IOException {
        System.out.println("Visited: " + (Path) dir);
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult preVisitDirectory(Object dir, BasicFileAttributes attrs)
                                                                      throws IOException {
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFile(Object file, BasicFileAttributes attrs)
                                                                      throws IOException {
        search((Path) file);
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFileFailed(Object file, IOException exc)
                                                                      throws IOException {
        //report an error if necessary

        return FileVisitResult.CONTINUE;
    }
}

class Main {

public static void main(String[] args) throws IOException {

 String words = "Rafael Nadal, tennis, winner of Roland Garros, BNP Paribas tournament draws";
 Search walk = new Search(words);
 EnumSet opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);

 Iterable<Path> dirs = FileSystems.getDefault().getRootDirectories();
 for (Path root : dirs) {
      Files.walkFileTree(root, opts, Integer.MAX_VALUE, walk);
 }

 System.out.println("____________________________________________________________");
 for(String path_string: walk.documents){
     System.out.println(path_string);` ` }
 System.out.println("____________________________________________________________");

 }
}`

请注意，有时这是一个相当慢的过程，可能需要几秒到几十分钟，运行时间会因文件树大小、检查的文件数量以及这些文件的大小而异。在前面的示例中，文件树包含默认文件系统中的所有文件存储，因此对于我们的搜索词集，将以任何受支持的格式打开、读取和浏览每个文件。根据匹配文件的大小和数量，在返回结果时，该过程可能会出现几秒钟的阻塞。您可以通过添加更多的文件格式、指示进程状态的进度条或标志以及加速进程的多线程来改进该应用。此外，显示找到的文件名可能比存储文件名和路径更好。

#### 编写文件删除应用

删除单个文件是一个简单的操作，正如你在第 4 章中看到的“删除文件和目录”在您调用了`delete()`或`deleteIfExists()`方法之后，该文件将从您的文件系统中删除。删除整个文件树是基于通过一个`FileVisitor`实现递归调用`delete()`或`deleteIfExists()`方法的操作。在看到示例之前，您需要记住以下几点:

*   删除目录之前，必须删除其中的所有文件。
*   `visitFile()`方法是执行每个文件删除的最佳位置。
*   因为只有当目录为空时才能删除，所以建议使用`postVisitDirectory()`方法删除目录。
*   如果一个文件不能被访问，`visitFileFailed()`方法应该返回`FileVisitResult.CONTINUE`或`TERMINATE`，这取决于您的决定。
*   删除过程可以遵循符号链接，这可能是不可取的，因为符号链接可能会指向删除域之外的文件。但是如果你确定这种情况永远不会发生，或者一个补充条件阻止了不期望的删除，那么就跟随符号链接。

我们在这一节的目标是创建一个删除整个文件树的应用。以下代码删除了`C:\rafaelnadal`目录(为了进一步使用，请在运行以下代码之前备份该目录):

`import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.EnumSet;`  `class DeleteDirectory implements FileVisitor {    

 boolean deleteFileByFile(Path file) throws IOException {
    return Files.deleteIfExists(file);
 }

 @Override
 public FileVisitResult postVisitDirectory(Object dir, IOException exc)
                                                                  throws IOException {

    if (exc == null) {
        System.out.println("Visited: " + (Path) dir);
        boolean success = deleteFileByFile((Path) dir);

        if (success) {
             System.out.println("Deleted: " + (Path) dir);
        } else {
              System.out.println("Not deleted: " + (Path) dir);
        }
    } else {
        throw exc;
    }
    return FileVisitResult.CONTINUE;
 }

 @Override
 public FileVisitResult preVisitDirectory(Object dir, BasicFileAttributes attrs)
                                                                  throws IOException {
   return FileVisitResult.CONTINUE;
 }

 @Override
 public FileVisitResult visitFile(Object file, BasicFileAttributes attrs)
                                                                  throws IOException {
   boolean success = deleteFileByFile((Path) file);

   if (success) {
        System.out.println("Deleted: " + (Path) file);
   } else {
        System.out.println("Not deleted: " + (Path) file);
   }

   return FileVisitResult.CONTINUE;
 }

 @Override
 public FileVisitResult visitFileFailed(Object file, IOException exc)
                                                                  throws IOException {
   //report an error if necessary

   return FileVisitResult.CONTINUE;
 }` `}

class Main {

 public static void main(String[] args) throws IOException {

   Path directory = Paths.get("C:/rafaelnadal");
   DeleteDirectory walk = new DeleteDirectory();
   EnumSet opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);

   Files.walkFileTree(directory, opts, Integer.MAX_VALUE, walk);      
   }
}`

![Image](images/square.jpg) **注意**将删除的文件发送到回收站可以通过使用 JNI 调用 Windows API `SHFileOperation()`方法来完成。查看大卫·谢伊在 www.jroller.com/ethdsy/entry/send_to_recycle_bin 的帖子了解更多细节。

#### 编写复制文件应用

复制文件树需要为每个遍历的文件和目录调用`Files.copy()`方法。(有关在 NIO.2 中复制文件或目录的详细信息，请参考[第 4 章](04.html#ch4)的“复制文件和目录”一节)在你看到一个例子之前，这里有一些要点要记住:

*   在从目录中复制任何文件之前，您必须复制目录本身。复制源目录(空或不空)将导致一个空的目标目录。该任务必须在`preVisitDirectory()`方法中完成。
*   `visitFile()`方法是复制每个文件的最佳地方。
*   当您复制文件或目录时，您需要决定是否要使用`REPLACE_EXISTING`和`COPY_ATTRIBUTES`选项。
*   如果您想保留源目录的属性，您需要在文件被复制之后，在`postVisitDirectory()`方法中这样做。
*   如果你选择跟随链接(`FOLLOW_LINKS`)并且你的文件树有一个到父目录的循环链接，循环目录在`visitFileFailed()`方法中被报告，带有`FileSystemLoopException`异常。
*   如果一个文件不能被访问，`visitFileFailed()`方法应该返回`FileVisitResult.CONTINUE`或`TERMINATE`，这取决于您的决定。
*   如果您指定了`FOLLOW_LINKS`选项，复制过程可以遵循符号链接。

下面的代码片段结合了前面的概念，并将`the` `C:\rafaelnadal`子树复制到`C:\rafaelnadal_copy`文件树中:

`import java.nio.file.FileSystemLoopException;` `import java.nio.file.attribute.FileTime;
import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.EnumSet;
import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;

class CopyTree implements FileVisitor {

   private final Path copyFrom;
   private final Path copyTo;

   public CopyTree(Path copyFrom, Path copyTo) {
        this.copyFrom = copyFrom;
        this.copyTo = copyTo;
    }

   static void copySubTree(Path copyFrom, Path copyTo) throws IOException {
        try {
            Files.copy(copyFrom, copyTo, REPLACE_EXISTING, COPY_ATTRIBUTES);
        } catch (IOException e) {
            System.err.println("Unable to copy " + copyFrom + " [" + e + "]");
        }

    }

   @Override
   public FileVisitResult postVisitDirectory(Object dir, IOException exc)
                                                                     throws IOException {
        if (exc == null) {
            Path newdir = copyTo.resolve(copyFrom.relativize((Path) dir));
            try {
                FileTime time = Files.getLastModifiedTime((Path) dir);
                Files.setLastModifiedTime(newdir, time);
            } catch (IOException e) {
                System.err.println("Unable to copy all attributes to: " + newdir+" ["+e+ "]");
            }
        } else {
            throw exc;
        }

        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult preVisitDirectory(Object dir, BasicFileAttributes attrs)
                                                                      throws IOException {` `        System.out.println("Copy directory: " + (Path) dir);
        Path newdir = copyTo.resolve(copyFrom.relativize((Path) dir));
        try {
            Files.copy((Path) dir, newdir, REPLACE_EXISTING, COPY_ATTRIBUTES);
        } catch (IOException e) {
            System.err.println("Unable to create " + newdir + " [" + e + "]");
            return FileVisitResult.SKIP_SUBTREE;
        }

        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFile(Object file, BasicFileAttributes attrs)
                                                                      throws IOException {
        System.out.println("Copy file: " + (Path) file);
        copySubTree((Path) file, copyTo.resolve(copyFrom.relativize((Path) file)));
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFileFailed(Object file, IOException exc)
                                                                     throws IOException {
        if (exc instanceof FileSystemLoopException) {
            System.err.println("Cycle was detected: " + (Path) file);
        } else {
            System.err.println("Error occurred, unable to copy:" +(Path) file+" ["+ exc + "]");
        }

        return FileVisitResult.CONTINUE;
    }
}

class Main {

    public static void main(String[] args) throws IOException {

        Path copyFrom = Paths.get("C:/rafaelnadal");
        Path copyTo = Paths.get("C:/rafaelnadal_copy");

        CopyTree walk = new CopyTree(copyFrom, copyTo);
        EnumSet opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);

        Files.walkFileTree(copyFrom, opts, Integer.MAX_VALUE, walk);
    }
}`

运行前面的应用后，您会发现一个与`C:\rafaelnadal`源具有相同内容和属性的`C:\rafaelnadal_copy`目标。

#### 编写一个移动文件应用

移动文件树是将复制和删除文件树的步骤组合到单个应用中的任务。(有关移动文件的更多详细信息，请参考第 4 章的“移动文件和目录”一节。)实际上，移动文件树通常有两种方法:组合使用`Files.move()`、`Files.copy()`和`Files.delete()`，或者只使用`Files.copy()`和`Files.delete()`。根据您选择的方法，应该相应地执行`FileVisitor`来完成移动文件树的任务。在看到示例之前，您需要记住以下几点:

*   在从目录中移动任何文件之前，您必须移动目录本身。由于不能移动非空目录(只能移动空目录)，您需要使用`Files.copy()`方法，它将复制一个空目录。该任务必须在`preVisitDirectory()`方法中完成。
*   `visitFile()`方法是移动每个文件的最佳位置。为此，您可以使用`Files.move()`方法，或者将`Files.copy()`与`Files.delete()`结合使用。
*   当一个源目录中的所有文件都被移动到目标目录中后，你需要调用`Files.delete()`来删除源目录，此时源目录应该是空的。该任务必须在`postVisitDirectory()`方法中完成。
*   当您复制文件或目录时，您需要决定是否要使用`REPLACE_EXISTING`和`COPY_ATTRIBUTES`选项。此外，当你移动一个文件或目录时，你需要决定是否需要`ATOMIC_MOVE`。
*   如果您想保留源目录的属性，您需要在文件被移动之后，在`postVisitDirectory()`方法中这样做。一些属性，如`lastModifiedTime`，应该在`preVisitDirectory()`方法中提取并存储，直到它们在`postVisitDirectory()`中被设置。原因是从源目录移动文件后，目录内容发生了变化，初始的最后修改时间被新日期覆盖。
*   如果一个文件不能被访问，`visitFileFailed()`方法应该返回`FileVisitResult.CONTINUE`或`TERMINATE`，这取决于您的决定。
*   如果指定了`FOLLOW_LINKS`选项，移动过程可以遵循符号链接。请记住，移动符号链接会移动链接本身，而不是链接的目标。

下面的代码片段将`C:\rafaelnadal`目录的内容移动到`C:\ATP\players\rafaelnafal`目录中(在测试之前，您必须手动创建文件夹`C:\ATP\players\`)。在这种情况下，使用`Files.copy()`和`Files.delete()`移动目录和子目录，使用`Files.move()`移动文件。

`import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;` `import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileTime;
import java.util.EnumSet;
import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;
import static java.nio.file.StandardCopyOption.ATOMIC_MOVE;

class MoveTree implements FileVisitor {

   private final Path moveFrom;
   private final Path moveTo;
   static FileTime time = null;

   public MoveTree(Path moveFrom, Path moveTo) {
        this.moveFrom = moveFrom;
        this.moveTo = moveTo;
   }

   static void moveSubTree(Path moveFrom, Path moveTo) throws IOException {
        try {
            Files.move(moveFrom, moveTo, REPLACE_EXISTING, ATOMIC_MOVE);
        } catch (IOException e) {
            System.err.println("Unable to move " + moveFrom + " [" + e + "]");
        }

   }

   @Override
   public FileVisitResult postVisitDirectory(Object dir, IOException exc)
                                                                     throws IOException {
        Path newdir = moveTo.resolve(moveFrom.relativize((Path) dir));
        try {
            Files.setLastModifiedTime(newdir, time);
            Files.delete((Path) dir);
        } catch (IOException e) {
            System.err.println("Unable to copy all attributes to: " + newdir+" [" + e + "]");
        }

        return FileVisitResult.CONTINUE;
   }

   @Override
   public FileVisitResult preVisitDirectory(Object dir, BasicFileAttributes attrs)
                                                                        throws IOException {
        System.out.println("Move directory: " + (Path) dir);
        Path newdir = moveTo.resolve(moveFrom.relativize((Path) dir));
        try {
            Files.copy((Path) dir, newdir, REPLACE_EXISTING, COPY_ATTRIBUTES);
            time = Files.getLastModifiedTime((Path) dir);
        } catch (IOException e) {` `            System.err.println("Unable to move " + newdir + " [" + e + "]");
            return FileVisitResult.SKIP_SUBTREE;
        }

        return FileVisitResult.CONTINUE;
   }

   @Override
   public FileVisitResult visitFile(Object file, BasicFileAttributes attrs)
                                                                        throws IOException {
        System.out.println("Move file: " + (Path) file);
        moveSubTree((Path) file, moveTo.resolve(moveFrom.relativize((Path) file)));
        return FileVisitResult.CONTINUE;
   }

   @Override
   public FileVisitResult visitFileFailed(Object file, IOException exc)
                                                                        throws IOException {
        return FileVisitResult.CONTINUE;
   }
}

class Main {

    public static void main(String[] args) throws IOException {

        Path moveFrom = Paths.get("C:/rafaelnadal");
        Path moveTo = Paths.get("C:/ATP/players/rafaelnadal");

        MoveTree walk = new MoveTree(moveFrom, moveTo);
        EnumSet opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);

        Files.walkFileTree(moveFrom, opts, Integer.MAX_VALUE, walk);
    }
}`

您可以不使用`Files.move()`来完成同样的任务，因为每次移动都只是一对复制和删除操作。例如，您可以重写`moveSubTree()`方法来使用`Files.copy()`和`Files.delete()`来移动文件:

```java
static void moveSubTree(Path moveFrom, Path moveTo) throws IOException {
        try {
            Files.copy(moveFrom, moveTo, REPLACE_EXISTING, COPY_ATTRIBUTES);
            Files.delete(moveFrom);
        } catch (IOException e) {
            System.err.println("Unable to move " + moveFrom + " [" + e + "]");
        }
    }
```

### 总结

本章着重于开发文件和目录的递归操作。在简单介绍了递归编程技术之后，您了解了`FileVisitor`接口和`SimpleFileVisitor`实现。然后，您看到了如何开发一组应用，您可以使用它们来执行涉及遍历文件树的任务，例如查找、复制、删除和移动文件。